# -*- coding: utf-8 -*-

"""
/***************************************************************************
 AggPoly
								 A QGIS plugin
 Aggregation of polygons within a certain distance and taking barriers into account.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
							  -------------------
		begin				: 2019-11-06
		copyright			: (C) 2019 by Friedrich Viedt
		email				: ***REMOVED***
 ***************************************************************************/

/***************************************************************************
 *																		 *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or	 *
 *   (at your option) any later version.								   *
 *																		 *
 ***************************************************************************/
"""

__author__ = 'Friedrich Viedt'
__date__ = '2019-11-06'
__copyright__ = '(C) 2019 by Friedrich Viedt'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import (QgsProcessing,
					   QgsFeatureSink,
					   QgsProcessingAlgorithm,
					   QgsProcessingParameterFeatureSource,
					   QgsProcessingParameterFeatureSink,
					   QgsProcessingParameterNumber,
					   QgsProcessingParameterDistance,
					   QgsFields,
					   QgsDataSourceUri)
import sqlite3
from qgis.core import QgsProcessingUtils, QgsVectorLayer
import processing


class AggPolyAlgorithm(QgsProcessingAlgorithm):
	"""
	This algorithm aggregates polygons within a certain distance and 
	taking barriers into account.
	
	The new features are build up from all valid triangles of 
	the input (polygon-) vertices.
	Only those triangles within a certain distance and disjoint from
	the barrier features are valid.
	"""
	
	# Constants used to refer to parameters and outputs. 
	OUTPUT = 'OUTPUT'
	INPUT = 'INPUT'
	SEARCH_DIST = 'SEARCH_DIST'
	BARRIER = 'BARRIER'
	
	# SQL Dict
	# TODO: use native spatialindex
	sql = {
		"attach":
			"ATTACH '{0}' AS named_sqlite;",
		
		"import":
			"CREATE TABLE '{0}' AS SELECT * FROM named_sqlite.{0};",
		
		"enable_spatialite":
			"SELECT load_extension('mod_spatialite'); \
			SELECT InitSpatialMetaData(1);",
		
		"c_empty_table":
			"CREATE TABLE {0};",
			
		"c_polygon_bb":
			"CREATE TABLE pol_layer_bb AS \
			SELECT pol_layer.id AS id, pol_layer.geometry AS pol_geom, BuildMbr(index_tab.xmin, index_tab.ymin, index_tab.xmax, index_tab.ymax, {}) AS bb \
			FROM pol_layer, idx_pol_layer_geometry AS index_tab \
			WHERE pol_layer.id = index_tab.pkid;",
			
		"c_polygon_distance":
			"CREATE TABLE pol_dist AS SELECT * FROM \
			(SELECT pol1.id AS pols_id, pol1.pol_geom AS pols_geom, pol2.id AS polt_id, pol2.pol_geom AS polt_geom \
			FROM pol_layer_bb AS pol1, pol_layer_bb AS pol2 \
			WHERE pol1.id <= pol2.id AND ST_Distance(pol1.bb, pol2.bb) <= {0}) \
			WHERE ST_Distance(pols_geom, polt_geom) <= {0};",
			
		"c_polygon_vertexes":
			"CREATE TABLE multipoints AS \
			SELECT *, NumGeometries(mpoi_geom) AS n_poi FROM \
			(SELECT pol.id, DissolvePoints(pol.pol_geom) AS mpoi_geom \
			FROM pol_layer_bb AS pol);",
		
		"s_max_n_mpoi":
			"SELECT MAX(n_poi) FROM multipoints;",
			
			"c_helper_t":
			"CREATE TABLE numbers AS \
			WITH RECURSIVE \
				cnt(x) AS ( \
					SELECT 1 \
					UNION ALL \
					SELECT x+1 FROM cnt \
					LIMIT {}) \
			SELECT x FROM cnt;",
		
		"c_points":
			"CREATE TABLE points AS \
			SELECT \
				id AS pol_id, \
				GeometryN(mpoi_geom, numbers.x) AS poi_geom \
			FROM \
				multipoints JOIN numbers \
				ON numbers.x <= n_poi;",
		
		"c_line":
			"CREATE TABLE poi_to_poi AS \
			SELECT p1.rowid AS pois_id, pols_id, polt_id, p2.rowid AS poit_id, MakeLine(p1.poi_geom, p2.poi_geom) AS l_geom \
			FROM points p1 \
			JOIN pol_dist d1 ON p1.pol_id = d1.pols_id \
			JOIN points p2 ON d1.polt_id = p2.pol_id \
			WHERE ST_Distance(p1.poi_geom, p2.poi_geom) <= {} AND ST_Distance(p1.poi_geom, p2.poi_geom) > 0;",
			
		"c_intersec_lines":
			"CREATE TABLE intersec_lines AS \
			SELECT poi_to_poi.rowid AS poi_id, ST_Intersects(poi_to_poi.l_geom, barrier_layer.geometry) AS intersec \
			FROM poi_to_poi, barrier_layer \
			WHERE intersec",
			
		"c_join_intersec":
			"CREATE TABLE poi_to_poi_no_intersec AS \
			SELECT poi_to_poi.* FROM poi_to_poi \
			LEFT JOIN intersec_lines ON poi_to_poi.rowid = intersec_lines.poi_id \
			WHERE intersec_lines.intersec IS NULL",
		
		"s_n_points":
			"SELECT COUNT(rowid) FROM points",
		
		"c_res":
			"CREATE TABLE named_sqlite.pol_res ( \
			poi INT, \
			geom GEOMETRY);",
		
		"c_subset_view":
			"CREATE VIEW poi_sel AS \
			SELECT * FROM poi_to_poi_no_intersec \
			WHERE pois_id = {};",
		
		"c_triangles":
			"CREATE TABLE triangles_sel AS \
			SELECT {} AS poi, BuildArea(Collect(Collect(p12.l_geom, p23.l_geom), p13.l_geom)) AS triangle \
			FROM poi_sel p12 INNER JOIN poi_to_poi_no_intersec p23 \
			ON p12.poit_id = p23.pois_id INNER JOIN poi_sel p13 \
			ON p23.poit_id = p13.poit_id;",
		
		"i_subset_res":
			"INSERT INTO pol_res (poi, geom) \
			SELECT poi, CastToMultiPolygon(ST_Union(triangle)) as geom \
			FROM triangles_sel \
			GROUP BY poi;",
		
		"d_subset_t":
			"DROP VIEW poi_sel; \
			DROP TABLE triangles_sel;",
		
		"recover_spatial":
			"SELECT RecoverGeometryColumn({0}, {1}, {2}, 'MULTIPOLYGON', 'XY'); \
			SELECT CreateSpatialIndex({0}, {1});"
			}

	def initAlgorithm(self, config):
		"""
		Here we define the inputs and output of the algorithm, along
		with some other properties.
		"""

		# We add the input vector features source. 
		self.addParameter(
			QgsProcessingParameterFeatureSource(
				self.INPUT,
				self.tr('Input layer'),
				[QgsProcessing.TypeVectorPolygon]
			)
		)

		# We add a feature sink in which to store our processed features (this
		# usually takes the form of a newly created vector layer when the
		# algorithm is run in QGIS).
		self.addParameter(
			QgsProcessingParameterFeatureSink(
				self.OUTPUT,
				self.tr('Output layer')
			)
		)
		
		# Add barrier source. It can have any kind of
		# geometry.
		self.addParameter(
			QgsProcessingParameterFeatureSource(
				self.BARRIER,
				self.tr('Barrier layer'),
				[QgsProcessing.TypeVectorAnyGeometry],
				optional = True
			)
		)
		
		# Add SEARCH_DIST
		self.addParameter(
			QgsProcessingParameterDistance(
				self.SEARCH_DIST,
				self.tr('Distance for aggregation'),
				500
			)
		)

	def processAlgorithm(self, parameters, context, feedback):
		"""
		Here is where the processing itself takes place.
		"""
		
		# Retrieve the feature source and sink. The 'dest_id' variable is used
		# to uniquely identify the feature sink, and must be included in the
		# dictionary returned by the processAlgorithm function.
		source = self.parameterAsSource(parameters, self.INPUT, context)
		source_uri = self.parameterAsString(parameters, self.INPUT, context)
		
		barrier = self.parameterAsSource(parameters, self.BARRIER, context)
		barrier_uri = self.parameterAsString(parameters, self.BARRIER, context)

		search_dist = self.parameterAsInt(parameters, self.SEARCH_DIST, context)
		
		(sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT,
				context, QgsFields(), source.wkbType(), source.sourceCrs())
		
		# Check for identical EPSG Code

		if barrier is None:
			epsg_inuse = source.sourceCrs().authid()
		elif source.sourceCrs().authid() == barrier.sourceCrs().authid():
			epsg_inuse = barrier.sourceCrs().authid()
		else:
			pass
			#TODO: stop
		
		# Compute the number of steps to display within the progress bar and
		# get features from source
		#total = 100.0 / source.featureCount() if source.featureCount() else 0
		#features = source.getFeatures()
		
		# TODO: simplyfy
		# TODO: segmetize
		# TODO: more exception handling
		# TODO: more robust
		# TODO: more feedback.isCanceled() checks
		
		# generate named spatialite-db and connect
		named_sqlite_uri = QgsProcessingUtils.generateTempFilename("aggPoly.sqlite")
		named_sqlite = QgsVectorLayer(named_sqlite_uri)
		# reference: https://github.com/qgis/QGIS/commit/6402160526e3176d1d41f422d6ecab59aa7ac68d
		con_n = sqlite3.connect(named_sqlite_uri)
		con_n.enable_load_extension(True)
		con_n.executescript(self.sql["enable_spatialite"])
		
		# generate memory spatialite-db
		# TODO: only if requested / not mandatory if named_sqlite_uri returns a path in TMPFS
		con_m = sqlite3.connect(':memory:')
		con_m.enable_load_extension(True)
		con_m.executescript(self.sql["enable_spatialite"])
		
		# TODO: only if memory-db requested
		#cur = con_n.cursor()
		cur = con_m.cursor()
		
		# import INPUTs in spatialite
		# TODO: accept shapefiles with mixed single- and multipart-features
		#source_single = processing.run("native:multiparttosingleparts", {'INPUT': source_uri, 'OUTPUT': 'memory'})
		
		processing.run("qgis:importintospatialite", {'INPUT': source_uri, 'DATABASE': named_sqlite, 'TABLENAME': 'pol_layer', 'GEOMETRY_COLUMN': 'geometry', 'CREATEINDEX': True, 'FORCE_SINGLEPART': True})
		if not barrier is None:
			processing.run("qgis:importintospatialite", {'INPUT': barrier_uri, 'DATABASE': named_sqlite, 'TABLENAME': 'barrier_layer', 'GEOMETRY_COLUMN': 'geometry', 'CREATEINDEX': True, 'FORCE_SINGLEPART': True})
		
		# TODO: use self.tr # Datenbank angelegt und Layer geladen.
		feedback.pushInfo("Database created and features imported.")
		
		# Do a lot in SQLite
		# TODO: # Lege neue Tabellen an und berechne Distanzen.
		feedback.pushInfo("Create new tables and calculate distances.")
		cur.execute(self.sql["attach"].format(named_sqlite_uri))
		cur.execute(self.sql["import"].format("pol_layer"))
		if not barrier is None:
			cur.execute(self.sql["import"].format("barrier_layer"))
		else: # TODO
			cur.execute("""CREATE TABLE barrier_layer (geometry BLOB);""")
		cur.execute(self.sql["c_polygon_bb"].format(epsg_inuse.split(":")[1]))
		cur.execute(self.sql["c_polygon_distance"].format(search_dist))
		cur.execute(self.sql["c_polygon_vertexes"])
		max_n_mpoi = cur.execute(self.sql["s_max_n_mpoi"]).fetchall()[0][0]
		cur.execute(self.sql["c_helper_t"].format(max_n_mpoi))
		cur.execute(self.sql["c_points"])
		cur.execute(self.sql["c_line"].format(search_dist))
		cur.execute(self.sql["c_intersec_lines"])
		cur.execute(self.sql["c_join_intersec"])
		n_poi = cur.execute(self.sql["s_n_points"]).fetchall()[0][0]
		cur.execute(self.sql["c_res"])

		# TODO: Alle notwendigen Tabellen angelegt.
		feedback.pushInfo("Tables created.")

		# TODO: test st_relate performance
		sql_dinters = "CREATE TABLE triangles_nointers AS \
			SELECT triangles_sel.poi AS poi, triangles_sel.triangle AS triangle\
			FROM triangles_sel, barrier_layer\
			WHERE NOT ST_Overlaps(triangles_sel.triangle, barrier_layer.geometry) AND NOT ST_Within(triangles_sel.triangle, barrier_layer.geometry);"
		
		sql_dtriint = "DROP TABLE triangles_nointers;"

		# TODO: # Beginne Dreiecks-Berechnung.
		feedback.pushInfo("Building polygons ...")
		
		for p in range(1, n_poi + 1):
			cur.execute(self.sql["c_subset_view"].format(p))
			cur.execute(self.sql["c_triangles"].format(p))
			#cur.execute("SELECT RecoverGeometryColumn('triangles_sel', 'triangle', {}, 'POLYGON', 'XY');".format(epsg_inuse.split(":")[1]))
			#cur.execute("SELECT CreateSpatialIndex('triangles_sel', 'triangle');")
			#cur.execute(sql_dinters)
			cur.execute(self.sql["i_subset_res"])
			cur.executescript(self.sql["d_subset_t"])
			#cur.execute(sql_dtriint)
			
			progress_percent = (p/float(n_poi))*100
			feedback.setProgress(progress_percent)
		
		cur.close()
		
		# recover spatial column in named_sqlite
		cur = con_n.cursor()
		cur.executescript(self.sql["recover_spatial"].format("'pol_res'", "'geom'", epsg_inuse.split(":")[1]))
		cur.close()
		
		con_n.close()
		con_m.close()

		# TODO: dissolve features
		# TODO: merge with source	
		
		# Copy features to sink
		named_sqlite_result_uri = QgsDataSourceUri()
		named_sqlite_result_uri.setDatabase(named_sqlite_uri)
		named_sqlite_result_uri.setDataSource('', 'pol_res', 'geom')
		named_sqlite_result = QgsVectorLayer(named_sqlite_result_uri.uri(), providerLib='spatialite')

		feedback.pushInfo("Copy features to output.")
		
		result_features = named_sqlite_result.getFeatures()
		for current, feature in enumerate(result_features):
			# Stop the algorithm if cancel button has been clicked
			if feedback.isCanceled():
				break
			
			# Add a feature in the sink
			sink.addFeature(feature, QgsFeatureSink.FastInsert)
			
			# TODO: Update the progress bar
			#feedback.setProgress(int(current * total))

		# Return the results of the algorithm.
		
		return {self.OUTPUT: dest_id}

	def name(self):
		"""
		Returns the algorithm name, used for identifying the algorithm. This
		string should be fixed for the algorithm, and must not be localised.
		The name should be unique within each provider. Names should contain
		lowercase alphanumeric characters only and no spaces or other
		formatting characters.
		"""
		return 'Aggregate polygons'

	def displayName(self):
		"""
		Returns the translated algorithm name, which should be used for any
		user-visible display of the algorithm name.
		"""
		return self.tr(self.name())

	def group(self):
		"""
		Returns the name of the group this algorithm belongs to. This string
		should be localised.
		"""
		return self.tr(self.groupId())

	def groupId(self):
		"""
		Returns the unique ID of the group this algorithm belongs to. This
		string should be fixed for the algorithm, and must not be localised.
		The group id should be unique within each provider. Group id should
		contain lowercase alphanumeric characters only and no spaces or other
		formatting characters.
		"""
		return 'Algorithms for vector layers'

	def tr(self, string):
		return QCoreApplication.translate('Processing', string)

	def createInstance(self):
		return AggPolyAlgorithm()
