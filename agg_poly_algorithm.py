# -*- coding: utf-8 -*-

"""
/***************************************************************************
 AggPoly
								 A QGIS plugin
 Aggregation of polygons within a certain distance and taking barriers into account.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
							  -------------------
		begin				: 2019-11-06
		copyright			: (C) 2019 by Friedrich Viedt
		email				: 57571099+fiedt@users.noreply.github.com
 ***************************************************************************/

/***************************************************************************
 *																		 *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or	 *
 *   (at your option) any later version.								   *
 *																		 *
 ***************************************************************************/
"""

__author__ = 'Friedrich Viedt'
__date__ = '2019-11-06'
__copyright__ = '(C) 2019 by Friedrich Viedt'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import (QgsProcessing,
					   QgsFeatureSink,
					   QgsProcessingAlgorithm,
					   QgsProcessingParameterVectorLayer,
					   QgsProcessingParameterFeatureSink,
					   QgsProcessingParameterNumber,
					   QgsProcessingParameterDistance,
					   QgsProcessingParameterBoolean,
					   QgsFields,
					   QgsDataSourceUri,
					   QgsProcessingException)
import sqlite3
from qgis.core import QgsProcessingUtils, QgsVectorLayer
import processing
from time import sleep


class AggPolyAlgorithm(QgsProcessingAlgorithm):
	"""
	This algorithm aggregates polygons within a certain distance and 
	taking barriers into account.
	
	The returned features are build up from all valid triangles of 
	the input (polygon-) vertices.
	Only those triangles with all segments shorter than the chosen distance 
	and disjoint from the barrier features are valid.
	"""
	
	# Constants used to refer to parameters and outputs. 
	OUTPUT = 'OUTPUT'
	INPUT = 'INPUT'
	SEARCH_DIST = 'SEARCH_DIST'
	DISSOLVE_WITH_INPUT = 'DISSOLVE_WITH_INPUT'
	BARRIER = 'BARRIER'
	SIMPLIFY_DIST = 'SIMPLIFY_DIST'
	
	# SQL Dict
	# TODO: test st_relate performance
	sql = {		
		"import":
			"""
			CREATE TABLE {0} AS 
				SELECT t.id AS id, CastToXY(e.geometry) AS geometry 
				FROM named_sqlite.{0} t
				JOIN ElementaryGeometries AS e ON (e.db_prefix = 'named_sqlite' AND e.f_table_name = '{0}' AND e.f_geometry_column = 'geometry' AND e.origin_rowid = t.rowid);
			""",

		"get_invalid_geometry":
			"""
			SELECT rowid FROM {table} WHERE NOT isValid({column});
			""",

		"drop_invalid_geometry":
			"""
			DELETE FROM {table} WHERE NOT isValid({column});
			""",

		"simplify_and_segmentize":
			"""
			UPDATE pol_layer SET geometry = st_segmentize(st_simplify(geometry,{simplify}),{segmentize});
			""",

		"segmentize_only":
			"""
			UPDATE pol_layer SET geometry = st_segmentize(geometry, {0});
			""",

		"simplify_only":
			"""
			UPDATE {table} SET geometry = st_simplify(geometry, {simplify});
			""",
		
		"enable_spatialite":
			"""
			SELECT load_extension('mod_spatialite'); 
			SELECT InitSpatialMetaData(1);
			""",
		
		"c_empty_table":
			"""
			CREATE TABLE {0};
			""",

		"c_polygon_distance":
			"""
			CREATE TABLE pol_dist AS 
				SELECT pol1.id AS pols_id, pol1.geometry AS pols_geom, pol2.id AS polt_id, pol2.geometry AS polt_geom FROM pol_layer pol1, pol_layer pol2
					WHERE 
						pol1.id <= pol2.id AND
						ST_Distance(pols_geom, polt_geom) <= {0} AND
						pol1.ROWID IN (SELECT ROWID FROM SpatialIndex WHERE f_table_name = 'pol_layer' AND search_frame = buffer(pol2.geometry, {0}));
			""",

		"dissolve_points":
			"""
			ALTER TABLE pol_layer ADD COLUMN mpoi_geom;
			UPDATE pol_layer SET mpoi_geom = DissolvePoints(geometry);
			""",

		"c_points":
			"""
			CREATE TABLE points AS 
				SELECT t.rowid AS pol_id, e.geometry AS poi_geom
				FROM pol_layer AS t
				JOIN ElementaryGeometries AS e ON (e.f_table_name = 'pol_layer' AND e.f_geometry_column = 'mpoi_geom' AND e.origin_rowid = t.rowid);
			""",

		"c_line":
			"""
			CREATE TABLE poi_to_poi AS 
				SELECT p1.rowid AS pois_id, pols_id, polt_id, p2.rowid AS poit_id, MakeLine(p1.poi_geom, p2.poi_geom) AS l_geom 
				FROM points p1 
				JOIN pol_dist d1 ON p1.pol_id = d1.pols_id 
				JOIN points p2 ON d1.polt_id = p2.pol_id 
				WHERE ST_Distance(p1.poi_geom, p2.poi_geom) <= {} 
					AND ST_Distance(p1.poi_geom, p2.poi_geom) > 0;
			""",
			
		"c_intersec_lines":
			"""
			CREATE TABLE intersec_lines AS 
				SELECT poi_to_poi.rowid AS poi_id, 1 AS intersec 
				FROM poi_to_poi, barrier_layer 
				WHERE ST_Crosses(poi_to_poi.l_geom, barrier_layer.geometry)
					AND poi_to_poi.ROWID IN (SELECT ROWID FROM SpatialIndex WHERE f_table_name = 'poi_to_poi' AND search_frame = barrier_layer.geometry);
			""",
		
		"c_join_intersec":
			"""
			CREATE TABLE poi_to_poi_no_intersec AS 
				SELECT poi_to_poi.* FROM poi_to_poi 
				LEFT JOIN intersec_lines ON poi_to_poi.rowid = intersec_lines.poi_id 
				WHERE intersec_lines.intersec IS NULL;
			""",
		
		"s_n_points":
			"""
			SELECT COUNT(rowid) FROM points
			""",
		
		"c_res":
			"""
			CREATE TABLE named_sqlite.pol_res ( 
			poi INT, 
			geom GEOMETRY);
			""",
		
		"c_view":
			"""
			CREATE VIEW poi_sel AS 
				SELECT * FROM poi_to_poi_no_intersec 
				WHERE pois_id = {0};
			""",
		
		"c_triangles":
			"""
			CREATE TABLE triangles_sel AS 
				SELECT {0} AS poi, BuildArea(Collect(Collect(p12.l_geom, p23.l_geom), p13.l_geom)) AS triangle 
				FROM poi_sel p12 
				INNER JOIN poi_to_poi_no_intersec p23 ON p12.poit_id = p23.pois_id 
				INNER JOIN poi_sel p13 ON p23.poit_id = p13.poit_id;
			""",

		"i_subset_res":
			"""
			INSERT INTO pol_res (poi, geom) 
				SELECT poi, CastToMultiPolygon(ST_Union(triangle)) as geom 
				FROM triangles_sel
				WHERE NOT triangles_sel.ROWID IN (
					SELECT triangles_sel.ROWID 
					FROM triangles_sel, barrier_layer
					WHERE (ST_Within(triangles_sel.triangle, barrier_layer.geometry) OR ST_Within(barrier_layer.geometry, triangles_sel.triangle))
						AND barrier_layer.ROWID IN (
							SELECT ROWID FROM SpatialIndex WHERE f_table_name = 'barrier_layer' AND search_frame = triangles_sel.triangle
							)
				);
			""",
		
		"recover_spatial":
			"""
			SELECT RecoverGeometryColumn('{table}', '{column}', {crs}, '{geometrytype}', 'XY'); 
			SELECT CreateSpatialIndex('{table}', '{column}');
			""",

		"get_geometrytype":
			"""
			SELECT st_geometrytype({column}) FROM {table} LIMIT 1;
			"""
			}

	def initAlgorithm(self, config):
		"""
		Here we define the inputs and output of the algorithm, along
		with some other properties.
		"""

		# We add the input vector features source. 
		self.addParameter(
			QgsProcessingParameterVectorLayer(
				self.INPUT,
				self.tr('Input layer'),
				[QgsProcessing.TypeVectorPolygon]
			)
		)

		# We add a feature sink in which to store our processed features (this
		# usually takes the form of a newly created vector layer when the
		# algorithm is run in QGIS).
		self.addParameter(
			QgsProcessingParameterFeatureSink(
				self.OUTPUT,
				self.tr('Output layer')
			)
		)
		
		# Add barrier source. It can have any kind of
		# geometry.
		self.addParameter(
			QgsProcessingParameterVectorLayer(
				self.BARRIER,
				self.tr('Barrier layer'),
				[QgsProcessing.TypeVectorAnyGeometry],
				optional = True
			)
		)
		
		# Add SEARCH_DIST
		self.addParameter(
			QgsProcessingParameterDistance(
				self.SEARCH_DIST,
				self.tr('Distance for aggregation'),
				500,
				'INPUT'
			)
		)

		# Add SIMPLIFY_DIST
		self.addParameter(
			QgsProcessingParameterDistance(
				self.SIMPLIFY_DIST,
				self.tr('Simplify input polygons (reduces processing time)'),
				1,
				'INPUT'
			)
		)

		# Add DISSOLVE_WITH_INPUT
		self.addParameter(
			QgsProcessingParameterBoolean(
				self.DISSOLVE_WITH_INPUT,
				self.tr('Dissolve result with input layer'),
				True
			)
		)

	# TODO: use GeoDB class
	def getSpatialConnetion (self, connect_to):
		con = sqlite3.connect(connect_to)
		con.enable_load_extension(True)
		con.executescript(self.sql["enable_spatialite"])
		return con

	def processAlgorithm(self, parameters, context, feedback):
		"""
		Here is where the processing itself takes place.
		"""
		
		# Retrieve the feature source and sink. The 'dest_id' variable is used
		# to uniquely identify the feature sink, and must be included in the
		# dictionary returned by the processAlgorithm function.
		source = self.parameterAsLayer(parameters, self.INPUT, context)
		
		barrier = self.parameterAsLayer(parameters, self.BARRIER, context)

		search_dist = self.parameterAsDouble(parameters, self.SEARCH_DIST, context)

		simplify_dist = self.parameterAsDouble(parameters, self.SIMPLIFY_DIST, context)

		dissolve_with_input = self.parameterAsBoolean(parameters, self.DISSOLVE_WITH_INPUT, context)
		
		(sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT,
				context, QgsFields(), source.wkbType(), source.sourceCrs())
		
		# Check for identical CRS
		if barrier is None:
			(epsg, srid) = source.sourceCrs().authid().split(":")
		elif source.sourceCrs().authid() == barrier.sourceCrs().authid():
			(epsg, srid) = barrier.sourceCrs().authid().split(":")
		else:
			raise QgsProcessingException(self.tr("Inputs in different CRS are not supported!"))
		assert epsg == "EPSG"
		
		# TODO: more exception handling, more robust
		# TODO: more feedback.isCanceled() checks
		
		# connect to named spatialite-db and memory spatialite-db
		named_sqlite_path = QgsProcessingUtils.generateTempFilename("aggPoly.sqlite")
		named_sqlite = QgsVectorLayer(named_sqlite_path)
		con_n = self.getSpatialConnetion(named_sqlite_path)
		con_m = self.getSpatialConnetion(':memory:')
		
		# create cursor
		cur = con_m.cursor()
		
		# import INPUTs in spatialite
		processing.run("qgis:importintospatialite", {'INPUT': source, 'DATABASE': named_sqlite, 'TABLENAME': 'pol_layer', 'GEOMETRY_COLUMN': 'geometry', 'CREATEINDEX': True, 'FORCE_SINGLEPART': True})
		if not barrier is None:
			processing.run("qgis:importintospatialite", {'INPUT': barrier, 'DATABASE': named_sqlite, 'TABLENAME': 'barrier_layer', 'GEOMETRY_COLUMN': 'geometry', 'CREATEINDEX': True, 'FORCE_SINGLEPART': True})
		
		# TODO: use self.tr # Datenbank angelegt und Layer geladen.
		feedback.pushInfo("Database created and features imported.")
		
		### Execute SQL
		feedback.pushInfo("Create new tables and calculate distances.")
		cur.execute("""ATTACH '{}' AS named_sqlite;""".format(named_sqlite_path))
		cur.execute(self.sql["import"].format("pol_layer"))
		if not barrier is None:
			cur.execute(self.sql["import"].format("barrier_layer"))
			geomtype_barrier_layer = cur.execute(self.sql["get_geometrytype"].format(column = "geometry", table = "barrier_layer")).fetchall()[0][0]
		else: # TODO
			cur.execute("""CREATE TABLE barrier_layer (geometry BLOB);""")
			geomtype_barrier_layer = 'POLYGON' # Dummy
		
		# simplify: less vertices reduces processing time
		# segmentize: ensure enough vertices
		if simplify_dist > 0:
			cur.execute(self.sql["simplify_and_segmentize"].format(segmentize = search_dist, simplify = simplify_dist))
			cur.execute(self.sql["simplify_only"].format(table = "barrier_layer", simplify = simplify_dist)) 
		else:
			cur.execute(self.sql["segmentize_only"].format(search_dist))
		# drop invalid geometries and recover spatialindex
		cur.execute(self.sql["drop_invalid_geometry"].format(table = "barrier_layer", column = "geometry")) 
		cur.executescript(self.sql["recover_spatial"].format(table = "barrier_layer", column = "geometry", crs = srid, geometrytype = geomtype_barrier_layer))
		cur.execute(self.sql["drop_invalid_geometry"].format(table = "pol_layer", column = "geometry")) 
		geomtype_pol_layer = cur.execute(self.sql["get_geometrytype"].format(column = "geometry", table = "pol_layer")).fetchall()[0][0]
		cur.executescript(self.sql["recover_spatial"].format(table = "pol_layer", column = "geometry", crs = srid, geometrytype = geomtype_pol_layer))
		
		cur.execute(self.sql["c_polygon_distance"].format(search_dist))
		cur.executescript(self.sql["dissolve_points"])
		cur.executescript(self.sql["recover_spatial"].format(table = "pol_layer", column = "mpoi_geom", crs = srid, geometrytype = "MULTIPOINT"))
		cur.execute(self.sql["c_points"])
		cur.execute(self.sql["c_line"].format(search_dist))
		cur.executescript(self.sql["recover_spatial"].format(table = "poi_to_poi", column = "l_geom", crs = srid, geometrytype = "LINESTRING"))
		cur.execute(self.sql["c_intersec_lines"])
		cur.execute(self.sql["c_join_intersec"])
		n_poi = cur.execute(self.sql["s_n_points"]).fetchall()[0][0]
		cur.execute(self.sql["c_res"])
		###

		feedback.pushInfo("Tables created and distances calculated.")
		feedback.pushInfo("Building polygons ...")
		
		# TODO: multi-threading
		for p in range(1, n_poi + 1):
			# Stop the algorithm if cancel button has been clicked
			if feedback.isCanceled():
				break

			cur.execute(self.sql["c_view"].format(p))
			cur.execute(self.sql["c_triangles"].format(p))
			cur.executescript(self.sql["recover_spatial"].format(table = "triangles_sel", column = "triangle", crs = srid, geometrytype = "POLYGON"))
			cur.execute(self.sql["i_subset_res"])
			cur.executescript("""DROP TABLE triangles_sel; DROP VIEW poi_sel;""")
			
			progress_percent = (p/float(n_poi))*100
			feedback.setProgress(progress_percent)
		
		cur.close()
		
		# recover spatial column in named_sqlite
		cur = con_n.cursor()
		cur.executescript(self.sql["recover_spatial"].format(table = "pol_res", column = "geom", crs = srid, geometrytype = "MULTIPOLYGON"))
		cur.close()
		
		con_n.close()
		con_m.close()
		
		# create result-QgsVectorLayer 
		named_sqlite_result_uri = QgsDataSourceUri()
		named_sqlite_result_uri.setDatabase(named_sqlite_path)
		named_sqlite_result_uri.setDataSource('', 'pol_res', 'geom')
		named_sqlite_result = QgsVectorLayer(named_sqlite_result_uri.uri(), providerLib='spatialite')

		### post-processing
		# which features should be dissolved	
		if dissolve_with_input:
			do_be_dissolved = processing.run("native:mergevectorlayers", {'LAYERS': [named_sqlite_result, source], 'OUTPUT': 'memory:'})
		else:
			do_be_dissolved = {'OUTPUT': named_sqlite_result}

		# dissolve features
		dissolved = processing.run("native:dissolve", {'INPUT': do_be_dissolved['OUTPUT'], 'OUTPUT': 'memory:'})

		# singlepart features
		singleparts = processing.run("native:multiparttosingleparts", {'INPUT': dissolved['OUTPUT'], 'OUTPUT': 'memory:'})
		###

		### Copy features to sink
		# TODO: how to write directly from processing algorithm native:multiparttosinglepart to sink?
		feedback.pushInfo("Copy features to output.")
		
		result_features = singleparts['OUTPUT'].getFeatures()
		for current, feature in enumerate(result_features):
			# Stop the algorithm if cancel button has been clicked
			if feedback.isCanceled():
				return None
			
			# Add a feature in the sink
			sink.addFeature(feature, QgsFeatureSink.FastInsert)
			
			# TODO: Update the progress bar
			#feedback.setProgress(int(current * total))
		###

		# Return the results of the algorithm.
		return {self.OUTPUT: dest_id}

	def name(self):
		"""
		Returns the algorithm name, used for identifying the algorithm. This
		string should be fixed for the algorithm, and must not be localised.
		The name should be unique within each provider. Names should contain
		lowercase alphanumeric characters only and no spaces or other
		formatting characters.
		"""
		return 'Aggregate polygons'

	def displayName(self):
		"""
		Returns the translated algorithm name, which should be used for any
		user-visible display of the algorithm name.
		"""
		return self.tr(self.name())

	def group(self):
		"""
		Returns the name of the group this algorithm belongs to. This string
		should be localised.
		"""
		return self.tr(self.groupId())

	def groupId(self):
		"""
		Returns the unique ID of the group this algorithm belongs to. This
		string should be fixed for the algorithm, and must not be localised.
		The group id should be unique within each provider. Group id should
		contain lowercase alphanumeric characters only and no spaces or other
		formatting characters.
		"""
		return 'Algorithms for vector layers'

	def tr(self, string):
		return QCoreApplication.translate('Processing', string)

	def createInstance(self):
		return AggPolyAlgorithm()
